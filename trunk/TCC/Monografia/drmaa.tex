\chapter{A Especificação DRMAA}
\label{cap:drmaa}

\emph{Distributed Resource Management Application API} (DRMAA) abstrai as diferenças dos RMS fornecendo uma API para programadores de aplicações distribuídas. 

O escopo da DRMAA é limitado em submeter, monitorar e controlar as aplicações, recuperando o \emph{status} de término da tarefa.

A idéia é que a API seja implementada em múltiplas linguagens. Implementada inicialmente em C/C++, tendo como segunda opção linguagens de \emph{scripts} tais como \emph{Perl} e \emph{Python}. O desenvolvimento da \emph{Interface Definition Language} (IDL) soluciona o problema através de uma \emph{interface} que serve para múltiplas linguagens.

Uma biblioteca ideal deveria servir, dinâmica e estaticamente, para todos RMS e suas versões. Porém, é possível implementar múltiplos mas não todos RMSs.

A idéia da implementação e aplicações distribuídas em larga escala são para um ambiente DRM e suas políticas. Nem sempre isto é possível, então uma solução menos intrusiva com uma "categoria de tarefa" e "especificação nativa", tem sido proposta. As políticas específicas do lugar são abstraídas/agregadas em simples \emph{strings} que são interpretadas pela implementação DRMAA. DRMAA não possui um mecanismo explícito de organização de arquivos  \cite{Rajic2004}. 

\section{Categorias de Tarefas}

Experiências com integrações em um DRM mostra que mesmo uma aplicação de mesmo \emph{Independent Software Vendor} (ISV) possuem políticas diferenciadas através de usuários. Essas políticas afetam atributos específicos tais como os recursos usados pela tarefa, preferência de localidade da execução da tarefa e onde a tarefa irá ser escalonada com relação a outras tarefas.

DRMAA fornece formas distintas para "\emph{job categories}" que encapsulam detalhes das tarefas específicas, escondendo estes detalhes da aplicação. É possível criar uma categoria de tarefa específica para uma aplicação a ser despachada pelo DRMS, o nome associado a categoria deve ser especificado como um atributo de submissão de tarefa. A DRMAA pode, então, usar o nome da categoria para gerenciar recursos específicos do local e requisitos funcionais das tarefas.

Um problema típico que dificulta a escrita para muitos ISVs é o não conhecimento prévio da configuração do DRMS, ainda assim a DRMAA facilita a escrita de aplicações \cite{Rajic2002}.

\section{DRMAA para PBS}

A biblioteca cobre aproximadamente toda a especificação DRMAA 1.0 com as exceções listadas \cite{drmaa_pbs}. Ela passou no teste oficial da \emph{suite} DRMAA com exceção dos testes que requerem \emph{status} de término de tarefa. Todos os obrigatórios e alguns atributos opcionais de tarefas são implementados.

\begin{itemize}
	\item com PBS, recuperar o \emph{status} de uma tarefa terminada é impossível. Por isso tarefas terminadas são marcadas como completas com código de retorno 0 desde que não tenham terminadas através da biblioteca.
	\item apenas são aceitas tarefas submetidas sob a sessão corrente (especificação diz que devem ser aceitas tarefas identificadas da sessão anterior).
	\item o estado do término da tarefa, quando realizado pelo PBS, é marcado como "abortado"  e  "marcado" qualquer que seja o estado.
	\item drmaa-wcoredump() sempre retorna \emph{false}.
\end{itemize}

\section{A Java \emph{Binding} API}

Apesar da especificação GFD.022 ter uma tendência para linguagem C, há uma liberdade para melhorar o ajuste com uma linguagem orientada a objetos como o Java. Alguns métodos sugerido na especificação não constam nos \emph{bindings} de linguagens orientadas a objetos. Os métodos drmaa\underline{ }get\underline{ }attribute(), drmaa\underline{ }set\underline{ }attribute(), drmaa\underline{ }get\underline{ }vector\underline{ }attribute(), drmaa\underline{ }set\underline{ }vector\underline{ }attribute() e drmaa\underline{ }get\underline{ }vector\underline{ } attribute \underline{ }names() não são necessários pois a especificação do \emph{binding} Java especifica uma propriedade \emph{\textbf{getter}} e \emph{\textbf{setter}} para cada atributo DRMAA. Um \emph{getter} é um método para recuperar valores e um método \emph{setter} para atribuir valores. Essas propriedades permitem, em tempo de compilação, checar os atributos DRMAA permitindo especial tratamento dos atributos que são melhores representados como algo diferente de uma \emph{String} \cite{Templeton2003}.

Alguns estudos realizados \cite{Herrera2007, Templeton2006} a fim de validar a especificação DRMAA constatam total viabilidade em usá-la. Mostrando-se totalmente flexível e útil, torna-se uma ferramenta viável para desenvolvimento tanto de ISV como para aplicações de usuários final.

No capítulo seguinte é feito uma análise do PBS, RMS usado na integração com o protótipo AppMan.